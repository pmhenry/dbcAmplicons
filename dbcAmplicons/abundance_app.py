# abundance_app.py
#
import sys
import os
import traceback
import re
import glob
import time
from dbcAmplicons import sampleTable
from collections import Counter
from collections import OrderedDict


class fixrankLine:
    """
    Parse a single line from fixrank formated file, generated by dbcAmplicons classify
    HWI-M01380:50:000000000-A641U:1:2116:11332:23553|Foxtrot267:16S         Bacteria        domain  1.0     "Fusobacteria"  phylum  1.0     "Fusobacteria"  class   1.0     "Fusobacteriales"     order   1.0     "Fusobacteriaceae"      family  1.0     Clostridium XIX genus   0.59
    """
    def __init__(self, line, rank='genus', threshold=0.5):
        """
        Initialize the fixrankLine object given a 'line'
        """
        # Assume good read
        self.goodRead = True
        self.barcode = None
        self.sample = None
        self.primer = None
        self.project = None
        self.size = None
        self.bootstrap = 1.0
        self.call = 'd__unknown'
        self.level = 'domain'

        parse = line.split('\t')

        # Question, how to describe unknown in Biom file?
        # Kingdon, Phylum, Class, Order, Family, Genes, Species
        fixrank_levels = ['d__', 'p__', 'c__', 'o__', 'f__', 'g__', 's__', 'i__']

        if len(parse) % 3 != 2:
            sys.stderr.write("ERROR:[fixrankline] incorrect number of columns in parsing the line, %s\n" % line)
            raise
        name = parse[0].split('|')
        name = name[1].split(':')
        self.barcode = self.sample = name[0]
        if (len(name) == 3):
            self.primer = name[1]
            self.size = name[2]
        else:
            self.size = name[1]
        # parse the taxon line
        levels = len(parse) / 3
        for i in xrange(levels):
            if float(parse[i * 3 + 4]) >= threshold:
                if i == 0:
                    self.call = fixrank_levels[i] + re.sub(r'["\']+', "", parse[i * 3 + 2])
                else:
                    self.call = self.call + ';' + fixrank_levels[i] + re.sub(r'["\']+', "", parse[i * 3 + 2])
                self.bootstrap = float(parse[i * 3 + 4])
                self.level = parse[i * 3 + 3]
                if parse[i * 3 + 3] == rank:
                    break
            else:
                break

    def getCall(self):
        """
        Retrieve the call
        """
        return self.call

    def getLevel(self):
        """
        Retreive the level the line was classified to
        """
        return self.level

    def getBootstrap(self):
        """
        Retreive bootstrap score
        """
        return self.bootstrap

    def getSize(self):
        """
        Retreive size
        """
        return self.size

    def isOk(self):
        """
        Return whether the read is 'good' True or 'bad' False
        """
        return self.goodRead

    def getSampleID(self):
        """
        Return the reads sample ID
        """
        return self.sample

    def getProject(self):
        """
        Return the reads project ID
        """
        return self.project

    def getPrimer(self):
        """
        Return the reads project ID
        """
        return self.primer

    def assignRead(self, sTable):
        """
        Given a samplesTable object, assign a sample ID and project ID using the reads barcode and primer designation
        """
        self.sample = sTable.getSampleID(self.barcode, self.primer)
        self.project = sTable.getProjectID(self.barcode, self.primer)
        self.goodRead = self.project is not None
        return 0


class abundanceApp:
    """
    Generate an abundance table from a fixrank formated file
    Takes fixrank formatted files from dbcAmplicons classify and a taxonomic rank to build table from, allowable values are (domain, phylum, class, order, family, genus, and species{if performed}
    and output an abundance and proportions table with taxon in rows and samples as columns.
    """
    def __init__(self):
        self.verbose = False

    def start(self, fixrank_file, samplesFile, output_prefix='table', rank='genus', threshold=0.5, minsize=None, maxsize=None, biom=False, hdf5=False, verbose=True, debug=False):
        """
            Start processing classification fixrank files
        """
        self.verbose = verbose
        evalSample = samplesFile is not None
        if biom or hdf5:
            try:
                import biom
            except ImportError:
                sys.stderr.write("Cannot import python biom module")
                raise
        try:
            lines = 0
            lasttime = time.time()
            self.ffixrank = []
            # samples
            if evalSample:
                sTable = sampleTable(samplesFile)
                if verbose:
                    sys.stdout.write("sample table length: %s, and %s projects.\n" % (sTable.getSampleNumber(), len(sTable.getProjectList())))

            # check input fixrank files
            for ffile in fixrank_file:
                self.ffixrank.extend(glob.glob(ffile))
                if len(self.ffixrank) == 0 or not all(os.path.isfile(f) for f in self.ffixrank):
                    sys.stderr.write('ERROR:[abundance_app] fixrank file(s) not found\n')
                    raise

            abundanceTable = dict()
            bootscore = dict()
            tax_len = dict()
            primers = dict()
            tax_level_counts = OrderedDict()
            tax_level_counts['domain'] = 0
            tax_level_counts['phylum'] = 0
            tax_level_counts['class'] = 0
            tax_level_counts['order'] = 0
            tax_level_counts['family'] = 0
            tax_level_counts['genus'] = 0
            tax_level_counts['species'] = 0
            tax_level_counts['isolate'] = 0
            sampleList = []
            sampleCounts = Counter()
            discardedReads = 0
            for ffile in self.ffixrank:
                with open(ffile, "rb") as infile:
                    for line in infile:
                        lrank = fixrankLine(line.rstrip('\n'), rank, threshold)
                        if (minsize is not None or maxsize is not None) and lrank.getSize() != "PAIR":
                            if minsize is not None and int(lrank.getSize()) < minsize:
                                discardedReads += 1
                                continue
                            if maxsize is not None and int(lrank.getSize()) > maxsize:
                                discardedReads += 1
                                continue
                        if evalSample:
                            lrank.assignRead(sTable)
                        if lrank.isOk():
                            if lrank.getLevel() not in tax_level_counts:
                                tax_level_counts[lrank.getLevel()] = 0
                            tax_level_counts[lrank.getLevel()] += 1
                            if lrank.getSampleID() not in sampleList:
                                sampleList.append(lrank.getSampleID())
                                primers[lrank.getSampleID()] = []
                            sampleCounts[lrank.getSampleID()] += 1
                            if lrank.getPrimer() is not None and lrank.getPrimer() not in primers[lrank.getSampleID()]:
                                primers[lrank.getSampleID()].append(lrank.getPrimer())
                            if lrank.getCall() in abundanceTable.keys():
                                abundanceTable[lrank.getCall()][lrank.getSampleID()] += 1
                                bootscore[lrank.getCall()] += lrank.getBootstrap()
                                if lrank.getSize() == "PAIR":
                                    tax_len[lrank.getCall()]["PAIR"] += 1
                                else:
                                    tax_len[lrank.getCall()]["SINGLE"] += int(lrank.getSize())
                            else:
                                abundanceTable[lrank.getCall()] = Counter()
                                abundanceTable[lrank.getCall()][lrank.getSampleID()] += 1
                                bootscore[lrank.getCall()] = lrank.getBootstrap()
                                tax_len[lrank.getCall()] = {}
                                if lrank.getSize() == "PAIR":
                                    tax_len[lrank.getCall()]["PAIR"] = 1
                                    tax_len[lrank.getCall()]["SINGLE"] = 0
                                else:
                                    tax_len[lrank.getCall()]["PAIR"] = 0
                                    tax_len[lrank.getCall()]["SINGLE"] = int(lrank.getSize())
                        lines += 1
                        if lines % 100000 is 0 and self.verbose:
                            sys.stderr.write("processed %s total lines, %s lines/second\n" % (lines, round(lines / (time.time() - lasttime), 0)))
            sys.stdout.write("%s lines processed in %s minutes\n" % (lines, round((time.time() - lasttime) / (60), 2)))

            sys.stdout.write("Classification numbers (reads):\n")
            for level in tax_level_counts:
                sys.stdout.write("   %s:\t%i\n" % (level, tax_level_counts[level]))
            if discardedReads > 0:
                sys.stdout.write("discarded %s reads for size\n" % str(discardedReads))
            if self.verbose:
                sys.stderr.write("Writing output\n")

            def calc_single_len(single, pairs, total):
                try:
                    return single / (total - pairs)
                except ZeroDivisionError:
                    return 0
            # output files
            # biom format
            if biom or hdf5:
                # generate table formats
                data = []
                obs_ids = []
                sampleList = sorted(sampleList, key=lambda s: s.lower())
                sampleList_md = [{'primers': ";".join(primers[v])} for v in sampleList]
                if evalSample:
                    if sTable.hasMetadata() is True:
                        for i, v in enumerate(sampleList):
                            sampleList_md[i].update(sTable.sampleMetadata[v]["Metadata"])

                # taxanomic keys and metadata
                taxa_keys = sorted(abundanceTable.keys(), key=lambda s: s.lower())
                mbootscore = {v: round(bootscore[v] / sum(abundanceTable[v].values()), 3) for v in taxa_keys}

                mtax_len_s = {v: calc_single_len(tax_len[v]["SINGLE"], tax_len[v]["PAIR"], sum(abundanceTable[v].values())) for v in taxa_keys}
                mtax_len_p = {v: round(tax_len[v]["PAIR"] / (sum(abundanceTable[v].values())), 3) for v in taxa_keys}

                def func(x):
                    return x.split(';')
                taxa_keys_md = [{'taxonomy': func(v), 'mean_rdp_bootstrap_value': mbootscore[v], 'mean_sequence_length_single': mtax_len_s[v], 'percentage_paired': mtax_len_p[v]} for v in taxa_keys]

                # build the data object
                for i, taxa in enumerate(taxa_keys):
                    obs_ids.append("Taxa_%05d" % (i))
                    tmpd = []
                    for sample in sampleList:
                        tmpd.append(float(abundanceTable[taxa][sample]))
                    data.append(tmpd)

                # build the biom Table object
                biomT = biom.Table(data=data, observation_ids=obs_ids, sample_ids=sampleList,
                                   observation_metadata=taxa_keys_md, sample_metadata=sampleList_md,
                                   input_is_dense=True,
                                   table_id=None, type="OTU table", create_date=None, generated_by="dbcAmplicons",
                                   observation_group_metadata=None, sample_group_metadata=None)

                if hdf5:
                    try:
                        import h5py  # Temporarily deactive h5py output (DISABLED)
                        sys.stderr.write("Writing hd5 formatted biom file to: %s\n" % (output_prefix + '.biom'))
                        with h5py.File(output_prefix + '.biom', 'w') as f:
                            biomT.to_hdf5(f, "dbcAmplicons")
                    except ImportError:
                        sys.stderr.write("h5py Import Error: Writing json formatted biom file to: %s\n" % (output_prefix + '.biom'))
                        with open(output_prefix + '.biom', 'w') as f:
                            f.write(biomT.to_json("dbcAmplicons"))
                else:
                        sys.stderr.write("Writing json formatted biom file to: %s\n" % (output_prefix + '.biom'))
                        with open(output_prefix + '.biom', 'w') as f:
                            f.write(biomT.to_json("dbcAmplicons"))

            # abundance and proportions tables
            if evalSample:
                ab_name = output_prefix + '.abundance.txt'
                prop_name = output_prefix + '.proportions.txt'
            else:
                ab_name = output_prefix + '.abundance.txt'
                prop_name = output_prefix + '.proportions.txt'
            try:
                abFile = open(ab_name, 'w')
                propFile = open(prop_name, 'w')
            except Exception:
                sys.stderr.write("ERROR:[abundance_app] Can't open files (%s,%s) for writing\n" % (ab_name, prop_name))
            sys.stderr.write("Writing abundance file to: %s\n" % (ab_name))
            sys.stderr.write("Writing proportions file to: %s\n" % (prop_name))
            # write out header line
            sampleList = sorted(sampleList, key=lambda s: s.lower())
            txt = 'Taxon_Name\tLevel\t' + '\t'.join(sampleList) + '\n'
            abFile.write(txt)
            propFile.write(txt)
            taxa_keys = sorted(abundanceTable.keys(), key=lambda s: s.lower())

            levels = {'d': 'domain', 'p': 'phylum', 'c': 'class', 'o': 'order', 'f': 'family', 'g': 'genus', 's': 'species', 'i': 'isolate'}
            for taxa in taxa_keys:
                tmp = taxa.split(";")[-1].split("__")

                txt1 = txt2 = tmp[1] + '\t' + levels[tmp[0]]
                for sample in sampleList:
                    txt1 = '\t'.join([txt1, str(abundanceTable[taxa][sample])])
                    if sampleCounts[sample] > 0:
                        txt2 = '\t'.join([txt2, str(float(abundanceTable[taxa][sample]) / float(sampleCounts[sample]))])
                    else:
                        txt2 = '\t'.join([txt2, str(0.0)])
                abFile.write(txt1 + '\n')
                propFile.write(txt2 + '\n')
            txt = "Sample Counts\tNA"
            for sample in sampleList:
                    txt = '\t'.join([txt, str(sampleCounts[sample])])
            propFile.write(txt + '\n')

            # output total counts and info (across all samples) for each taxa
            cntFile = open(output_prefix + '.taxa_info.txt', 'w')
            cntFile.write("Taxon_Name\tMeanBootstrapValue\tMeanLengthMerged\tPercentageAsPairs\tTotal\n")
            taxa_keys = sorted(abundanceTable.keys(), key=lambda s: s.lower())

            for abt in taxa_keys:
                cntFile.write(str(abt) + '\t' +
                              str(round(bootscore[abt] / sum(abundanceTable[abt].values()), 3)) + '\t' +
                              str(calc_single_len(tax_len[abt]["SINGLE"], tax_len[abt]["PAIR"], sum(abundanceTable[abt].values()))) + '\t' +
                              str(round(tax_len[abt]["PAIR"] / (sum(abundanceTable[abt].values())), 3)) + '\t' +
                              str(sum(abundanceTable[abt].values())) + '\n')
            if self.verbose:
                sys.stderr.write("finished in %s minutes\n" % (round((time.time() - lasttime) / (60), 2)))
            self.clean()
            return 0
        except (KeyboardInterrupt, SystemExit):
            self.clean()
            sys.stderr.write("%s unexpectedly terminated\n" % (__name__))
            return 1
        except Exception:
            self.clean()
            sys.stderr.write("A fatal error was encountered.\n")
            if debug:
                sys.stderr.write("".join(traceback.format_exception(*sys.exc_info())))
            return 1

    def clean(self):
        if self.verbose:
            sys.stderr.write("Cleaning up.\n")
        try:
            # nothing to be done
            pass
        except Exception:
            pass
